import { UniversalTranscriptService } from './universal-transcript-service'

interface YouTubeSearchResult {
  videoId: string;
  title: string;
  channelTitle: string;
  duration: string;
  matchScore: number;
  transcriptAvailable: boolean;
}

interface YouTubeTranscript {
  text: string;
  segments: Array<{
    text: string;
    start: number;
    duration: number;
  }>;
  language: string;
  isAutoGenerated: boolean;
  source: 'youtube' | 'deepgram' | 'cache';
  cost: number;
  processingTime: number;
}

export class YouTubeTranscriptService {
  private apiKey: string;
  private youtubeAPI = 'https://www.googleapis.com/youtube/v3';
  private universalTranscript: UniversalTranscriptService;

  constructor() {
    this.apiKey = process.env.YOUTUBE_API_KEY || '';
    this.universalTranscript = UniversalTranscriptService.getInstance();
  }

  /**
   * Main entry point: Search for episode transcript
   */
  async searchEpisodeTranscript(episode: {
    title: string;
    podcastTitle: string;
    host: string;
    duration: number;
    releaseDate: string;
  }): Promise<YouTubeTranscript | null> {
    
    console.log(`🔍 Searching YouTube for: "${episode.title}"`);

    // Stage 1: Generate search queries with different strategies
    const searchQueries = this.generateSearchQueries(episode);
    
    // Stage 2: Search YouTube with each query
    const searchResults = await this.performYouTubeSearches(searchQueries);
    
    // Stage 3: Filter and rank results
    const rankedResults = this.rankSearchResults(searchResults, episode);
    
    // Stage 4: Try to extract transcript from best matches
    for (const result of rankedResults.slice(0, 3)) { // Try top 3 matches
      const transcript = await this.extractTranscript(result.videoId);
      if (transcript) {
        console.log(`✅ Found transcript on YouTube: ${result.title}`);
        return transcript;
      }
    }

    console.log(`❌ No YouTube transcript found for: ${episode.title}`);
    return null;
  }

  /**
   * Generate multiple search query variations
   */
  private generateSearchQueries(episode: any): string[] {
    const { title, podcastTitle, host } = episode;
    
    // Clean up common podcast title variations
    const cleanPodcast = podcastTitle
      .replace(/podcast/gi, '')
      .replace(/show/gi, '')
      .trim();

    const cleanTitle = title
      .replace(/[:|#]/g, '')
      .replace(/episode\s*\d+/gi, '')
      .trim();

    return [
      // Exact match attempts
      `"${title}" "${podcastTitle}"`,
      `"${title}" "${cleanPodcast}"`,
      
      // Podcast + guest/topic
      `"${cleanPodcast}" ${this.extractMainTopic(title)}`,
      `"${podcastTitle}" ${this.extractMainTopic(title)}`,
      
      // Host + guest/topic  
      `"${host}" ${this.extractMainTopic(title)}`,
      
      // Broader searches
      `${cleanPodcast} ${this.extractKeywords(title).join(' ')}`,
      `${host} ${this.extractKeywords(title).join(' ')}`,
      
      // Fallback
      `${cleanTitle}`,
    ].filter(query => query.length > 10); // Filter out too-short queries
  }

  /**
   * Extract main topic/guest from episode title
   */
  private extractMainTopic(title: string): string {
    // Common patterns for extracting guest names or main topics
    const patterns = [
      /with\s+([^:|,]+)/i,           // "with John Doe"
      /featuring\s+([^:|,]+)/i,      // "featuring Jane Smith"  
      /([A-Z][a-z]+\s+[A-Z][a-z]+)/, // "John Doe" (proper names)
      /^([^:|]+):/,                  // "Topic: rest of title"
    ];

    for (const pattern of patterns) {
      const match = title.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    // Fallback: first few words
    return title.split(' ').slice(0, 3).join(' ');
  }

  /**
   * Extract important keywords from title
   */
  private extractKeywords(title: string): string[] {
    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were']);
    
    return title
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 3 && !stopWords.has(word))
      .slice(0, 5); // Top 5 keywords
  }

  /**
   * Perform YouTube searches with different queries
   */
  private async performYouTubeSearches(queries: string[]): Promise<YouTubeSearchResult[]> {
    const allResults: YouTubeSearchResult[] = [];
    
    for (const query of queries.slice(0, 5)) { // Limit to 5 searches to avoid quota issues
      try {
        const results = await this.searchYouTube(query);
        allResults.push(...results);
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 200));
      } catch (error) {
        console.warn(`YouTube search failed for query: ${query}`, error);
      }
    }

    // Remove duplicates by videoId
    const uniqueResults = allResults.filter((result, index, self) => 
      self.findIndex(r => r.videoId === result.videoId) === index
    );

    return uniqueResults;
  }

  /**
   * Search YouTube API
   */
  private async searchYouTube(query: string): Promise<YouTubeSearchResult[]> {
    const url = `${this.youtubeAPI}/search?` + new URLSearchParams({
      part: 'snippet',
      q: query,
      type: 'video',
      maxResults: '10',
      order: 'relevance',
      key: this.apiKey,
    });

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`YouTube API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.items?.map((item: any) => ({
      videoId: item.id.videoId,
      title: item.snippet.title,
      channelTitle: item.snippet.channelName,
      duration: 'unknown', // Would need additional API call for duration
      matchScore: 0, // Will be calculated in ranking
      transcriptAvailable: false, // Will be checked during extraction
    })) || [];
  }

  /**
   * Rank search results by relevance to episode
   */
  private rankSearchResults(results: YouTubeSearchResult[], episode: any): YouTubeSearchResult[] {
    return results
      .map(result => ({
        ...result,
        matchScore: this.calculateMatchScore(result, episode)
      }))
      .sort((a, b) => b.matchScore - a.matchScore);
  }

  /**
   * Calculate how well a YouTube video matches the episode
   */
  private calculateMatchScore(result: YouTubeSearchResult, episode: any): number {
    let score = 0;
    
    const resultTitle = result.title.toLowerCase();
    const episodeTitle = episode.title.toLowerCase();
    const podcastTitle = episode.podcastTitle.toLowerCase();
    const channelTitle = result.channelTitle.toLowerCase();

    // Exact title match (highest score)
    if (resultTitle.includes(episodeTitle) || episodeTitle.includes(resultTitle)) {
      score += 50;
    }

    // Podcast name in channel title
    if (channelTitle.includes(podcastTitle) || podcastTitle.includes(channelTitle)) {
      score += 30;
    }

    // Host name in channel title
    if (episode.host && channelTitle.includes(episode.host.toLowerCase())) {
      score += 25;
    }

    // Common keywords
    const episodeKeywords = this.extractKeywords(episode.title);
    const resultKeywords = this.extractKeywords(result.title);
    const commonKeywords = episodeKeywords.filter(keyword => 
      resultKeywords.some(rKeyword => rKeyword.includes(keyword) || keyword.includes(rKeyword))
    );
    score += commonKeywords.length * 5;

    // Penalty for likely clips (vs full episodes)
    if (resultTitle.includes('clip') || resultTitle.includes('highlight')) {
      score -= 10;
    }

    // Bonus for likely full episodes
    if (resultTitle.includes('full') || resultTitle.includes('complete') || resultTitle.includes('episode')) {
      score += 10;
    }

    return score;
  }

  /**
   * Extract transcript from YouTube video using Universal Transcript Service
   */
  private async extractTranscript(videoId: string): Promise<YouTubeTranscript | null> {
    try {
      console.log(`🎬 Extracting transcript for video: ${videoId}`);
      
      // Use the Universal Transcript Service (YouTube + Deepgram hybrid)
      const result = await this.universalTranscript.getTranscript(videoId);
      
      if (!result || !result.isAvailable || result.transcript.length === 0) {
        console.log(`❌ No transcript available for video ${videoId}`);
        return null;
      }

      console.log(`✅ Got transcript from ${result.source} for video ${videoId} (cost: $${result.cost.toFixed(4)})`);

      // Process into our format
      return {
        text: result.transcript.map(segment => segment.text).join(' '),
        segments: result.transcript.map(segment => ({
          text: segment.text,
          start: segment.start,
          duration: segment.duration,
        })),
        language: 'en',
        isAutoGenerated: result.source === 'youtube' || result.source === 'deepgram',
        source: result.source,
        cost: result.cost,
        processingTime: result.processingTime
      };
    } catch (error) {
      console.warn(`Failed to extract transcript for video ${videoId}:`, error);
      return null;
    }
  }

  /**
   * Get transcript using youtube-transcript library
   */
  private async getYouTubeTranscript(videoId: string): Promise<any[] | null> {
    // This would use a library like 'youtube-transcript'
    // For now, returning mock implementation
    
    try {
      // const { YoutubeTranscript } = require('youtube-transcript');
      // return await YoutubeTranscript.fetchTranscript(videoId);
      
      // Mock implementation
      console.log(`🎬 Attempting to extract transcript from video: ${videoId}`);
      return null; // Would return actual transcript data
    } catch (error) {
      console.warn(`Transcript extraction failed for ${videoId}:`, error);
      return null;
    }
  }

  /**
   * Check if video has captions available
   */
  async checkCaptionsAvailable(videoId: string): Promise<boolean> {
    try {
      const url = `${this.youtubeAPI}/captions?` + new URLSearchParams({
        part: 'snippet',
        videoId: videoId,
        key: this.apiKey,
      });

      const response = await fetch(url);
      const data = await response.json();
      
      return data.items && data.items.length > 0;
    } catch (error) {
      console.warn(`Failed to check captions for ${videoId}:`, error);
      return false;
    }
  }
} 